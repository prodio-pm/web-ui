<div class="ink-grid vertical-space">
  <p>Welcome to Prodio, a different take on Project Management.</p>
  <p>Prodio takes a different approach to Project Management. Instead of forcing
    you into a standard or process Prodio lets you define the process and helps
    you automate your way to completion.</p>
  <p>Under the hood Prodio is nothing more than a simple Graph Database holding
    your projects tasks (as nodes) and reference data (as edges).  This means
    that Prodio can model any popular Project Management Process (like Kanban,
    Scrum, Waterfall, etc) or can be used with its own different approach.</p>
  <p>Prodio's default behavior is to utilize a simple to navigate and manage
    Mindmap to display, edit, and track your progress.  Adding a new task,
    feature, story, or whatever you want to call it is simple.  Open the project
    and add in a new node.  Then go to reports to view how the new node affects
    the project as a whole.</p>
  <h2>General Principles</h2>
  <p>All systems have rules and while Prodio strives to have a few as possible
    it seems like a good idea to at least set some general principles. These
    are loosely based on that of a 12 factor app.</p>
  <h3>Function over Form</h3>
  <p>Architects like Form over Function where the shape of a building or object
    is based upon its function or purpose.</p>
  <p>Prodio takes Function over Form where the function of the service or
    method is more important than the Form it is chosen to be implemented in.</p>
  <p>This means that it does not matter what language, databse, or style you
    decide to implement a particular function in, it only matters that it
    does exactly as it is designed to do.</p>
  <h3>Micro-service driven</h3>
  <p>To the extent possible everything should be developed with the though of
    micro services in mind.  All functions should do one thing and one thing
    only.  It should be little to no effort to modify or completely replace a
    particular function without impacting any other function within Prodio.</p>
  <h3>Consistency</h3>
  <p>While it is true that "Function over Form" is a rule, it is also true that
    consistency matters.  For any given language there are always a set of do's
    and dont's.  Ensure that you follow these.</p>
  <p>An example of this would be indention, if a function is designed using 2
    space characters, then you should not utilize tabs.  If it was designed
    with tabs, then you should not utilize spaces.</p>
  <p>Consistency matters only at the functional level.  Functions may differ.</p>
  <h3>Scale Horizontally</h3>
  <p>This is similar to the Concurrency model of the 12 Factor app.  Where by
    the program should "Scale out via the process model."</p>
  <p>To this end all functions should be able to operate within their own
    process model. This allows more work to be taken in by adding forking
    processes for the overloaded function without taking into consideration
    any special needs.</p>
  <h3>Backend Independent</h3>
  <p>At no time shall any function not directly designed for data persistence
    require a specific storge facility.  All requests for data shall be provided
    through a function designed only for storage, retrieval, or modification
    of data at rest.  Data in motion may never be mutated.</p>
  <p>The only exception to this is that ALL data within the system shall be
    delivered or conveyed using JSON. All query operations shall be represented
    via JSON and shall conform to the standards as set in the data query
    section.</p>
  <h3>Be Idempotent</h3>
  <p>01+01 must always equal 10.</p>
  <p>This is to say that given a known input to a function it should always
    produce the same known output.</p>
  <p>As an example, changing the description of a project or item should always
    return an object with the updated address.</p>
  <p>The elevator button is another good example of idempotent functionality:
    "The initial activation of the button moves the system into a requesting
    state, until the request is satisfied. Subsequent activations of the button
    between the initial activation and the request being satisfied have no
    effect."</p>
  <h3>Be Immutable</h3>
  <p>Passed data shall never be modified or mutated. New data may be created,
    but it can never be mutated. This is the nature of a Service Bus and must
    be adhered to in order to ensure horizontal scaling.</p>
  <h3>Share Nothing</h3>
  <p>Any data that needs to be persisted must be stored in a stateful service
    that can be utilized by other services.  At no point will caching be
    utilized outside of a single execution of any given function.</p>
  <h3>The Rule of Jim</h3>
  <p>I once worked with a man named Jim. Jim was known for being a bit odd. If
    you wanted to break something, you gave it to Jim. If you wanted to know
    the limits of something, you gave it to Jim.</p>
  <p>An example was the concepts of tasks and sub-tasks. These were introduced
    as "Create a task or sub-task for every action." Within 24 hours Jim had
    crashed the system by creating a tree 20+ levels deep containing over 400
    tasks and sub-task combinations. Rather than resolve the process or "fix"
    the application Jim was told to stop.</p>
  <p>In so much as is possible don't make the edge case stop. If it is correct
    for someone to create such a tree then let it be created, let it be
    navigated, and if it doesn't work then fix it.</p>
  <h2>Data Query Language</h2>
  <p>To aid with the intgration of most Data Stores a common query language
    must exist and must be defined. To keep with the ability to store queries
    as JSON a structure is borrowed from that of Sift and MongoDB. All
    operations listed below must be implmented for a data store to be considered
    acceptable. In some cases, such as the memory store or the LevelDB store,
    sift may be directly utilized to traverse and filter the results before
    returning them to the caller.</p>
  <p>The following was taken from the Sift documentation and reduced to fit
    the larger audience.</p>

  <h3>$in</h3>
  <p>array value must be $in the given query:</p>
  <p>Intersecting two arrays:</p>
  <pre><code>  //filtered: ['Brazil']
  filter({ $in: ['Costa Rica','Brazil'] }, ['Brazil','Haiti','Peru','Chile']);</code></pre>
  <p>Here's another example. This acts more like the $or operator:</p>
  <pre><code>  filter({ location: { $in: ['Costa Rica','Brazil'] } }, { name: 'Craig', location: 'Brazil' });</code></pre>

  <h3>$nin</h3>
  <p>Opposite of $in:</p>
  <pre><code>  //filtered: ['Haiti','Peru','Chile']
  filter({ $nin: ['Costa Rica','Brazil'] }, ['Brazil','Haiti','Peru','Chile']);</code></pre>

  <h3>$exists</h3>
  <p>Checks if whether a value exists:</p>
  <pre><code>  //filtered: ['Craig','Tim']
  filter({ $exists: true }, ['Craig',null,'Tim']);</code></pre>
  <p>You can also filter out values that don't exist</p>
  <pre><code>  //filtered: [{ name: 'Craig', city: 'Minneapolis' }]
  filter({ city: { $exists: false } }, [ { name: 'Craig', city: 'Minneapolis' }, { name: 'Tim' }]);</code></pre>

  <h3>$gte</h3>
  <p>Checks if a number is >= value:</p>
  <pre><code>  //filtered: [2, 3]
  filter({ $gte: 2 }, [0, 1, 2, 3]);</code></pre>

  <h3>$gt</h3>
  <p>Checks if a number is > value:</p>
  <pre><code>  //filtered: [3]
  filter({ $gt: 2 }, [0, 1, 2, 3]);</code></pre>

  <h3>$lte</h3>
  <p>Checks if a number is <= value.</p>
  <pre><code>  //filtered: [0, 1, 2]
  filter({ $lte: 2 }, [0, 1, 2, 3]);</code></pre>

  <h3>$lt</h3>
  <p>Checks if number is < value.</p>
  <pre><code>  //filtered: [0, 1]
  filter({ $lt: 2 }, [0, 1, 2, 3]);</code></pre>

  <h3>$eq</h3>
  <p>Checks if query == value. Note that $eq can be omitted. For $eq, and $neq</p>
  <pre><code>  //filtered: [{ state: 'MN' }]
  filter({ state: {$eq: 'MN' }}, [{ state: 'MN' }, { state: 'CA' }, { state: 'WI' });</code></pre>
  <p>Or:</p>
  <pre><code>  //filtered: [{ state: 'MN' }]
  filter({ state: 'MN' }, [{ state: 'MN' }, { state: 'CA' }, { state: 'WI' });</code></pre>

  <h3>$ne</h3>
  <p>Checks if query != value.</p>
  <pre><code>  //filtered: [{ state: 'CA' }, { state: 'WI'}]
  filter({ state: {$ne: 'MN' }}, [{ state: 'MN' }, { state: 'CA' }, { state: 'WI' });</code></pre>

  <h3>$all</h3>
  <p>values must match everything in array:</p>
  <pre><code>  //filtered: [ { tags: ['books','programming','travel' ]} ]
  filter({ tags: {$all: ['books','programming'] }}, [
  { tags: ['books','programming','travel' ] },
  { tags: ['travel','cooking'] } ]);</code></pre>

  <h3>$and</h3>
  <p>ability to use an array of expressions. All expressions must test true.</p>
  <pre><code>  //filtered: [ { name: 'Craig', state: 'MN' }]
  filter({ $and: [ { name: 'Craig' }, { state: 'MN' } ] }, [
  { name: 'Craig', state: 'MN' },
  { name: 'Tim', state: 'MN' },
  { name: 'Joe', state: 'CA' } ]);</code></pre>

  <h3>$or</h3>
  <p>OR array of expressions.</p>
  <pre><code>  //filtered: [ { name: 'Craig', state: 'MN' }, { name: 'Tim', state: 'MN' }]
  filter({ $or: [ { name: 'Craig' }, { state: 'MN' } ] }, [
  { name: 'Craig', state: 'MN' },
  { name: 'Tim', state: 'MN' },
  { name: 'Joe', state: 'CA' } ]);</code></pre>

  <h3>$nor</h3>
  <p>opposite of or:</p>
  <pre><code>  //filtered: [ { name: 'Tim', state: 'MN' }, { name: 'Joe', state: 'CA' }]
  filter({ $nor: [ { name: 'Craig' }, { state: 'MN' } ] }, [
  { name: 'Craig', state: 'MN' },
  { name: 'Tim', state: 'MN' },
  { name: 'Joe', state: 'CA' } ]);</code></pre>

  <h3>$regex</h3>
  <p>Matches values based on the given regular expression</p>
  <pre><code>  filter({ $regex: /^f/i, $nin: ["frank"] }, ["frank", "fred", "sam", "frost"]); // ["fred", "frost"]</code></pre>

  <h3>$not</h3>
  <p>Not expression:</p>
  <pre><code>  filter({$not:{$in:['craig','tim']}}, ['craig','tim','jake']); //['jake']
  filter({$not:{$size:5}}, ['craig','tim','jake']); //['tim','jake']</code></pre>
</div>
